<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<HTML>
<HEAD>
<TITLE>SWI-Prolog Natural Language Processing Primitives</TITLE><style type="text/css"> 
dd.defbody 
{ margin-bottom: 1em; 
} 

dt.pubdef 
{ background-color: #c5e1ff; 
} 

pre.code 
{ margin-left: 1.5em; 
margin-right: 1.5em; 
border: 1px dotted; 
padding-top: 5px; 
padding-left: 5px; 
padding-bottom: 5px; 
background-color: #f8f8f8; 
}
</style>
</HEAD>
<BODY BGCOLOR="white"> 
<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<CENTER>

<H1>SWI-Prolog Natural Language Processing Primitives</H1>

</CENTER>
<HR>
<CENTER>
<I>Jan Wielemaker <BR>
HCS, <BR>
University of Amsterdam <BR>
The Netherlands <BR>
E-mail: <A HREF="mailto:wielemak@science.uva.nl">wielemak@science.uva.nl</A></I>
</CENTER>
<HR>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>
<CENTER><H3>Abstract</H3></Center>
<TABLE WIDTH="90%" ALIGN=center BORDER=2 BGCOLOR="#f0f0f0"><TR><TD>
This package contains some well known basic routines for natural 
language processing and information retrieval. The current version of 
this package is very limited, which makes the name somewhat misleading. 
Suggestions and contributions are welcome.
</TABLE>

<H1><A NAME="document-contents">Table of Contents</A></H1>

<UL>
<LI><A HREF="#sec:1"><B>1 Double Metaphone -- Phonetic string matching</B></A>
<UL>
<LI><A HREF="#sec:1.1">1.1 Origin and Copyright</A>
</UL>
<LI><A HREF="#sec:2"><B>2 Porter Stem -- Determine stem and related 
routines</B></A>
<UL>
<LI><A HREF="#sec:2.1">2.1 Origin and Copyright</A>
</UL>
<LI><A HREF="#sec:3"><B>3 Installation</B></A>
<UL>
<LI><A HREF="#sec:3.1">3.1 Unix systems</A>
</UL>
</UL>

<P>

<H2><A NAME="sec:1">1 Double Metaphone -- Phonetic string matching</A></H2>

<P>The library <CODE>library(double_metaphone)</CODE> implements the <EM>Double 
Metaphone</EM> algorithm developed by Lawrence Philips and described in 
``The Double-Metaphone Search Algorithm'' by L Philips, C/C++ Userâ€™s 
Journal, 2000. Double Metaphone creates a key from a word that 
represents its phonetic properties. Two words with the same Double 
Metaphone are supposed to sound similar. The Double Metaphone algorithm 
is an improved version of the <EM>Soundex</EM> algorithm.

<DL>
<DT class="pubdef"><A NAME="double_metaphone/2"><STRONG>double_metaphone</STRONG>(<VAR>+In, 
-MetaPhone</VAR>)</A><DD class="defbody">
Same as <A NAME="idx:doublemetaphone3:1"></A><A HREF="#double_metaphone/3">double_metaphone/3</A>, 
but only returning the primary metaphone.
<DT class="pubdef"><A NAME="double_metaphone/3"><STRONG>double_metaphone</STRONG>(<VAR>+In, 
-MetaPhone, -AltMetaphone</VAR>)</A><DD class="defbody">
Create metaphone and alternative metaphone from <VAR>In</VAR>. The 
primary metaphone is based on english, while the secondary deals with 
common alternative pronounciation in other languages. <VAR>In</VAR> is 
either and atom, string object, code- or character list. The metaphones 
are always returned as atoms.
</DL>

<H3><A NAME="sec:1.1">1.1 Origin and Copyright</A></H3>

<P>The Double Metaphone algorithm is copied from the Perl library that 
holds the following copyright notice. To the best of our knowledge the 
Perl license is compatible to the SWI-Prolog license schema and 
therefore including this module poses no additional license conditions.
<BLOCKQUOTE> Copyright 2000, Maurice Aubrey &lt;maurice@hevanet.com&gt;. 
All rights reserved.

<P>This code is based heavily on the C++ implementation by Lawrence 
Philips and incorporates several bug fixes courtesy of Kevin Atkinson 
&lt;kevina@users.sourceforge.net&gt;.

<P>This module is free software; you may redistribute it and/or modify 
it under the same terms as Perl itself.
</BLOCKQUOTE>

<H2><A NAME="sec:2">2 Porter Stem -- Determine stem and related routines</A></H2>

<P>The <CODE>library(porter_stem)</CODE> library implements the stemming 
algorithm described by Porter in Porter, 1980, ``An algorithm for suffix 
stripping'', Program, Vol. 14, no. 3, pp 130-137. The library comes with 
some additional predicates that are commonly used in the context of 
stemming.

<DL>
<DT class="pubdef"><A NAME="porter_stem/2"><STRONG>porter_stem</STRONG>(<VAR>+In, 
-Stem</VAR>)</A><DD class="defbody">
Determine the stem of <VAR>In</VAR>. <VAR>In</VAR> must represent ISO 
Latin-1 text. The <A NAME="idx:porterstem2:2"></A><A HREF="#porter_stem/2">porter_stem/2</A> 
predicate first maps <VAR>In</VAR> to lower case, then removes all 
accents as in <A NAME="idx:unaccentatom2:3"></A><A HREF="#unaccent_atom/2">unaccent_atom/2</A> 
and finally applies the Porter stem algorithm.<DT class="pubdef"><A NAME="unaccent_atom/2"><STRONG>unaccent_atom</STRONG>(<VAR>+In, 
-ASCII</VAR>)</A><DD class="defbody">
If <VAR>In</VAR> is general ISO Latin-1 text with accents, <VAR>ASCII</VAR> 
is unified with a plain ASCII version of the string. Note that the 
current version only deals with ISO Latin-1 atoms.<DT class="pubdef"><A NAME="tokenize_atom/2"><STRONG>tokenize_atom</STRONG>(<VAR>+In, 
-TokenList</VAR>)</A><DD class="defbody">
Break the text <VAR>In</VAR> into words, numbers and punctuation 
characters. Tokens are created to the following rules:

<P>
<TABLE BORDER=0 FRAME=void RULES=groups>
<TR VALIGN=top><TD><CODE>[-+][0-9]+(\.[0-9]+)?([eE][0-9]+)</CODE> </TD><TD>number </TD></TR>
<TR VALIGN=top><TD><CODE>[:alpha:][:alnum:]+</CODE> </TD><TD>word </TD></TR>
<TR VALIGN=top><TD><CODE>[:space:]+</CODE> </TD><TD>skipped </TD></TR>
<TR VALIGN=top><TD>anything else</TD><TD>single-character</TD></TR>
</TABLE>

<P>It is likely that future versions of this library will provide
<A NAME="idx:tokenizeatom3:4"></A><B>tokenize_atom/3</B> with additional 
options to modify space handling as well as the definition of words.<DT class="pubdef"><A NAME="atom_to_stem_list/2"><STRONG>atom_to_stem_list</STRONG>(<VAR>+In, 
-ListOfStems</VAR>)</A><DD class="defbody">
Combines the three above routines, returning a list holding an atom with 
the stem of each word encountered and numbers for encountered numbers.
</DL>

<H3><A NAME="sec:2.1">2.1 Origin and Copyright</A></H3>

<P>The code is based on the original Public Domain implementation by 
Martin Porter as can be found at
<A HREF="http://www.tartarus.org/martin/PorterStemmer/">http://www.tartarus.org/martin/PorterStemmer/</A>. 
The code has been modified by Jan Wielemaker. He removed all global 
variables to make the code thread-safe, added the unaccent and tokenize 
code and created the SWI-Prolog binding.

<H2><A NAME="sec:3">3 Installation</A></H2>

<H3><A NAME="sec:3.1">3.1 Unix systems</A></H3>

<P>Installation on Unix system uses the commonly found <EM>configure</EM>,
<EM>make</EM> and <EM>make install</EM> sequence. SWI-Prolog should be 
installed before building this package. If SWI-Prolog is not installed 
as <B>pl</B>, the environment variable <CODE>PL</CODE> must be set to 
the name of the SWI-Prolog executable. Installation is now accomplished 
using:

<PRE class="code">
% ./configure
% make
% make install
</PRE>

<P>This installs the foreign libraries in <CODE>$PLBASE/lib/$PLARCH</CODE> 
and the Prolog library files in <CODE>$PLBASE/library</CODE>, where
<CODE>$PLBASE</CODE> refers to the SWI-Prolog `home-directory'.

<H1><A NAME="document-index">Index</A></H1>

<DL>
<DT><STRONG>A</STRONG><DD>
<DT><A HREF="#atom_to_stem_list/2">atom_to_stem_list/2</A><DD>
<DT><STRONG>D</STRONG><DD>
<DT><A HREF="#double_metaphone/2">double_metaphone/2</A><DD>
<DT><A HREF="#double_metaphone/3">double_metaphone/3</A><DD>
<A HREF="#idx:doublemetaphone3:1">1</A>
<DT><STRONG>P</STRONG><DD>
<DT><A HREF="#porter_stem/2">porter_stem/2</A><DD>
<A HREF="#idx:porterstem2:2">2</A>
<DT><STRONG>T</STRONG><DD>
<DT><A HREF="#tokenize_atom/2">tokenize_atom/2</A><DD>
<DT>tokenize_atom/3<DD>
<A HREF="#idx:tokenizeatom3:4">2</A>
<DT><STRONG>U</STRONG><DD>
<DT><A HREF="#unaccent_atom/2">unaccent_atom/2</A><DD>
<A HREF="#idx:unaccentatom2:3">2</A>
</DL>

</BODY></HTML>